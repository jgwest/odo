package component

import (
	"encoding/json"
	"fmt"
	"sync"
	"testing"
	"time"

	adaptersCommon "github.com/openshift/odo/pkg/devfile/adapters/common"
	devfileParser "github.com/openshift/odo/pkg/devfile/parser"
	"github.com/openshift/odo/pkg/kclient"
	"github.com/openshift/odo/pkg/machineoutput"
	"github.com/openshift/odo/pkg/testingutil"

	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

func TestStatusReconciler(t *testing.T) {
	componentName := "my-component"

	tests := []struct {
		name              string
		pre               []*corev1.Pod
		expectedPreEvents int
		post              []*corev1.Pod
		successFn         func(lfo *logFuncOutput) string
	}{
		{
			name:              "a new pod should trigger a status update",
			pre:               []*corev1.Pod{},
			expectedPreEvents: 0,
			post: []*corev1.Pod{
				createFakePod(componentName, componentName, nil),
			},
			successFn: func(lfo *logFuncOutput) string {

				latestPodStatus := lfo.getMostRecentKubernetesPodStatus()
				if latestPodStatus == nil {
					return "pod not found"
				}
				if len(latestPodStatus.Pods) != 1 {
					return fmt.Sprintf("unexpected pod size, %v", lfo.debugSprintAll())
				}

				if latestPodStatus.Pods[0].Name != "my-component" {
					return fmt.Sprintf("mismatching component %v", lfo.debugSprintAll())
				}

				return ""
			},
		},
		{
			name: "if a pod is deleted, trigger a status update",
			pre: []*corev1.Pod{
				createFakePod(componentName, componentName, func(pod *corev1.Pod) {
					pod.UID = "one"
				}),
			},
			expectedPreEvents: 1,
			post:              []*corev1.Pod{},
			successFn: func(lfo *logFuncOutput) string {
				time.Sleep(5 * time.Second)
				if lfo.listSize() > 0 {
					return fmt.Sprintf("Unexpected event after deletion: %v", lfo.debugSprintAll())
				}
				return ""
			},
		},
		{
			name: "if a pod is updated, trigger a status update",
			pre: []*corev1.Pod{
				createFakePod(componentName, componentName, func(pod *corev1.Pod) {
					pod.UID = "one"
					pod.Status.Phase = corev1.PodPending
				}),
			},
			expectedPreEvents: 1,
			post: []*corev1.Pod{
				createFakePod(componentName, componentName, func(pod *corev1.Pod) {
					pod.UID = "one"
					pod.Status.Phase = corev1.PodRunning
				}),
			},
			successFn: func(lfo *logFuncOutput) string {
				latestPodStatus := lfo.getMostRecentKubernetesPodStatus()
				if latestPodStatus == nil {
					return "pod not found"
				}
				if len(latestPodStatus.Pods) != 1 {
					return fmt.Sprintf("unexpected pod size, %v", lfo.debugSprintAll())
				}

				if latestPodStatus.Pods[0].Name != "my-component" {
					return fmt.Sprintf("mismatching component, %v", lfo.debugSprintAll())
				}

				if latestPodStatus.Pods[0].Phase != string(corev1.PodRunning) {
					return fmt.Sprintf("unexpected pod phase, %v", lfo.debugSprintAll())
				}

				return ""

			},
		},

		{
			name:              "no changes should trigger no events",
			pre:               []*corev1.Pod{},
			expectedPreEvents: 0,
			post:              []*corev1.Pod{},
			successFn: func(lfo *logFuncOutput) string {
				time.Sleep(5 * time.Second)

				if lfo.listSize() > 0 {
					return fmt.Sprintf("unexpected events in output %v", lfo.debugSprintAll())
				}

				return ""
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			devObj := devfileParser.DevfileObj{
				Data: &testingutil.TestDevfileData{},
			}

			adapterCtx := adaptersCommon.AdapterContext{
				ComponentName: componentName,
				Devfile:       devObj,
			}

			fkclient, _ := kclient.FakeNew()

			adapter := New(adapterCtx, *fkclient)

			logFuncOutput := logFuncOutput{}

			adapter.machineEventLogger = machineoutput.NewConsoleMachineEventLoggingClientWithFunction(logFuncOutput.logFunc)

			reconcilerChannel := createStatusReconciler(&adapter)

			// Initialize with an empty list
			reconcilerChannel <- statusReconcilerChannelEntry{
				pods:                   []*corev1.Pod{},
				err:                    nil,
				isCompleteListOfPods:   true,
				isDeleteEventFromWatch: false,
			}

			// Send the initial simulated cluster status before the test runs
			reconcilerChannel <- statusReconcilerChannelEntry{
				pods:                   tt.pre,
				err:                    nil,
				isCompleteListOfPods:   false,
				isDeleteEventFromWatch: false,
			}

			// Wait for the expected number of events that will be generated by sending the initial faux cluster status
			expireTime := time.Now().Add(5 * time.Second)
			for logFuncOutput.listSize()-tt.expectedPreEvents != 0 {
				time.Sleep(20 * time.Millisecond)

				if time.Now().After(expireTime) {
					t.Fatalf("unexpected number of pre events: %v", logFuncOutput.debugSprintAll())
				}
			}

			// Clear the expected events
			logFuncOutput.clearList()

			// Send the test's simulated cluster status
			reconcilerChannel <- statusReconcilerChannelEntry{
				pods:                   tt.post,
				err:                    nil,
				isCompleteListOfPods:   false,
				isDeleteEventFromWatch: false,
			}

			// Wait up to 10 seconds for the test to signal success (an empty string, indicating no errors)
			expireTime = time.Now().Add(10 * time.Second)
			mostRecentError := ""
			for {
				failureReason := tt.successFn(&logFuncOutput)

				mostRecentError = failureReason

				if failureReason == "" {
					break
				}

				if time.Now().After(expireTime) {
					break
				}
			}

			if mostRecentError != "" {
				t.Fatal(mostRecentError)
			}

			if logFuncOutput.errorOccurred != nil {
				t.Fatalf("error occurred during test case run %v", logFuncOutput.errorOccurred)
			}

		})
	}

}

type logFuncOutput struct {
	jsonList      []machineoutput.MachineEventLogEntry
	listMutex     sync.Mutex
	errorOccurred error
}

func (lfo *logFuncOutput) getMostRecentKubernetesPodStatus() *machineoutput.KubernetesPodStatus {

	lfo.listMutex.Lock()
	defer lfo.listMutex.Unlock()

	var podStatus *machineoutput.KubernetesPodStatus

	for _, entry := range lfo.jsonList {

		if entry.GetType() == machineoutput.TypeKubernetesPodStatus {
			podStatus = entry.(*machineoutput.KubernetesPodStatus)
		}
	}

	return podStatus
}

func (lfo *logFuncOutput) listSize() int {
	lfo.listMutex.Lock()
	defer lfo.listMutex.Unlock()

	return len(lfo.jsonList)
}

func (lfo *logFuncOutput) debugSprintAll() string {

	lfo.listMutex.Lock()
	defer lfo.listMutex.Unlock()

	result := ""

	for _, entry := range lfo.jsonList {
		jsonVal, err := json.Marshal(entry)
		if err != nil {
			lfo.errorOccurred = err
			return fmt.Sprint(err)
		}
		result += string(jsonVal)
	}

	return result
}

func (lfo *logFuncOutput) clearList() {
	lfo.listMutex.Lock()
	defer lfo.listMutex.Unlock()

	lfo.jsonList = []machineoutput.MachineEventLogEntry{}
}

func (lfo *logFuncOutput) logFunc(wrapper machineoutput.MachineEventWrapper) {

	lfo.listMutex.Lock()
	defer lfo.listMutex.Unlock()

	json, err := wrapper.GetEntry()
	if err != nil {
		lfo.errorOccurred = err
		return
	}

	machineoutput.OutputSuccessUnindented(wrapper)

	lfo.jsonList = append(lfo.jsonList, json)
}

func createFakePod(componentName, podName string, fn func(*corev1.Pod)) *corev1.Pod {
	fakePod := &corev1.Pod{
		ObjectMeta: metav1.ObjectMeta{
			Name: podName,
			Labels: map[string]string{
				"component": componentName,
			},
		},
		Status: corev1.PodStatus{
			Phase: corev1.PodRunning,
		},
	}

	if fn != nil {
		fn(fakePod)
	}

	return fakePod
}
